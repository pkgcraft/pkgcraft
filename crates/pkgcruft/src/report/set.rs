use std::fmt;
use std::str::FromStr;
use std::sync::LazyLock;

use pkgcraft::restrict::Scope;
use regex::Regex;

use crate::Error;
use crate::check::{Check, CheckKind, Context};

use super::{ReportKind, ReportLevel};

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
pub enum RangeOrValue<T: Eq + Copy> {
    Value(T),
    Range(Range<T>),
}

impl<T: PartialEq + Eq + PartialOrd + Copy> RangeOrValue<T> {
    /// Determine if the given value is contained.
    fn contains(&self, value: &T) -> bool {
        match self {
            Self::Value(x) => x == value,
            Self::Range(range) => range.contains(value),
        }
    }
}

impl<T> FromStr for RangeOrValue<T>
where
    T: FromStr + Eq + Copy,
    T::Err: fmt::Display + fmt::Debug,
{
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Ok(value) = s.parse() {
            Ok(RangeOrValue::Value(value))
        } else if let Ok(value) = s.parse() {
            Ok(RangeOrValue::Range(value))
        } else {
            Err(Error::InvalidValue(format!("invalid range or value: {s}")))
        }
    }
}

impl<T: fmt::Display + Eq + Copy> fmt::Display for RangeOrValue<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Value(value) => value.fmt(f),
            Self::Range(value) => value.fmt(f),
        }
    }
}

impl From<ReportLevel> for RangeOrValue<ReportLevel> {
    fn from(value: ReportLevel) -> Self {
        Self::Value(value)
    }
}

impl From<Scope> for RangeOrValue<Scope> {
    fn from(value: Scope) -> Self {
        Self::Value(value)
    }
}

// TODO: replace regex with value parser
static RANGE_OP_RE: LazyLock<Regex> =
    LazyLock::new(|| Regex::new(r"^(?<op>[<>]=?|!?=)(?<value>.+)$").unwrap());

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
pub enum Range<T: Eq + Copy> {
    Less(T),
    LessOrEqual(T),
    Equal(T),
    NotEqual(T),
    GreaterOrEqual(T),
    Greater(T),
}

impl<T: PartialEq + Eq + PartialOrd + Copy> Range<T> {
    /// Determine if a range contains a value.
    fn contains(&self, value: &T) -> bool {
        match self {
            Self::Less(x) => value < x,
            Self::LessOrEqual(x) => value <= x,
            Self::Equal(x) => value == x,
            Self::NotEqual(x) => value != x,
            Self::GreaterOrEqual(x) => value >= x,
            Self::Greater(x) => value > x,
        }
    }
}

impl<T> FromStr for Range<T>
where
    T: FromStr + Eq + Copy,
    T::Err: fmt::Display + fmt::Debug,
{
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some(caps) = RANGE_OP_RE.captures(s) {
            let op = caps.name("op").map_or("", |m| m.as_str());
            let value = caps.name("value").map_or("", |m| m.as_str());
            let value = value.parse().map_err(|e| {
                Error::InvalidValue(format!("invalid range value: {value}: {e}"))
            })?;
            match op {
                "<" => Ok(Self::Less(value)),
                "<=" => Ok(Self::LessOrEqual(value)),
                "=" => Ok(Self::Equal(value)),
                "!=" => Ok(Self::NotEqual(value)),
                ">=" => Ok(Self::GreaterOrEqual(value)),
                ">" => Ok(Self::Greater(value)),
                _ => unreachable!("invalid Range regex"),
            }
        } else {
            Err(Error::InvalidValue(format!("invalid range op: {s}")))
        }
    }
}

impl<T: fmt::Display + Eq + Copy> fmt::Display for Range<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Less(value) => write!(f, "<{value}"),
            Self::LessOrEqual(value) => write!(f, "<={value}"),
            Self::Equal(value) => write!(f, "={value}"),
            Self::NotEqual(value) => write!(f, "!={value}"),
            Self::GreaterOrEqual(value) => write!(f, ">={value}"),
            Self::Greater(value) => write!(f, ">{value}"),
        }
    }
}

/// Report sets that relate to one or more variants.
#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]
pub enum ReportSet {
    /// All supported report variants.
    All,

    /// Report variants requiring finalization.
    Finalize,

    /// Report variants generated by a check.
    Check(CheckKind),

    /// Report variants requiring a given context, e.g. only valid in an overlay.
    Context(Context),

    /// Report variants with levels matching the given range.
    Level(RangeOrValue<ReportLevel>),

    /// Unit set consisting of the given report variant.
    Report(ReportKind),

    /// Report variants with scopes matching the given range.
    Scope(RangeOrValue<Scope>),
}

impl From<Check> for ReportSet {
    fn from(value: Check) -> Self {
        Self::Check(value.kind)
    }
}

impl From<CheckKind> for ReportSet {
    fn from(value: CheckKind) -> Self {
        Self::Check(value)
    }
}

impl From<Context> for ReportSet {
    fn from(value: Context) -> Self {
        Self::Context(value)
    }
}

impl From<ReportLevel> for ReportSet {
    fn from(value: ReportLevel) -> Self {
        Self::Level(value.into())
    }
}

impl From<ReportKind> for ReportSet {
    fn from(value: ReportKind) -> Self {
        Self::Report(value)
    }
}

impl From<Scope> for ReportSet {
    fn from(value: Scope) -> Self {
        Self::Scope(value.into())
    }
}

impl FromStr for ReportSet {
    type Err = Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some(val) = s.strip_prefix('@') {
            match val {
                "all" => Ok(Self::All),
                "finalize" => Ok(Self::Finalize),
                _ => val
                    .parse()
                    .map(Self::Check)
                    .or_else(|_| val.parse().map(Self::Context))
                    .or_else(|_| val.parse().map(Self::Level))
                    .or_else(|_| val.parse().map(Self::Scope))
                    .map_err(|_| Error::InvalidValue(format!("invalid report set: {val}"))),
            }
        } else {
            s.parse()
                .map(Self::Report)
                .map_err(|_| Error::InvalidValue(format!("invalid report: {s}")))
        }
    }
}

impl fmt::Display for ReportSet {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::All => write!(f, "@all"),
            Self::Finalize => write!(f, "@finalize"),
            Self::Check(check) => write!(f, "@{check}"),
            Self::Context(context) => write!(f, "@{context}"),
            Self::Level(level) => write!(f, "@{level}"),
            Self::Report(report) => write!(f, "{report}"),
            Self::Scope(scope) => write!(f, "@{scope}"),
        }
    }
}

impl ReportSet {
    /// Return true if the related reports should be added to the selected set.
    pub(super) fn selected(&self) -> bool {
        matches!(self, Self::Report(_) | Self::Check(_))
    }

    /// Expand a report set into an iterator of its variants.
    pub(crate) fn expand<'a, I, J>(
        self,
        default: I,
        supported: J,
    ) -> Box<dyn Iterator<Item = ReportKind> + 'a>
    where
        I: IntoIterator<Item = &'a ReportKind>,
        I::IntoIter: 'a,
        J: IntoIterator<Item = &'a ReportKind>,
        J::IntoIter: 'a,
    {
        let default = default.into_iter();
        let supported = supported.into_iter();

        match self {
            Self::All => Box::new(supported.copied()),
            Self::Finalize => {
                Box::new(default.filter(|r| r.finish_check(Scope::Repo)).copied())
            }
            Self::Check(check) => Box::new(check.reports().iter().copied()),
            Self::Context(context) => Box::new(
                Check::iter_report(supported)
                    .filter(move |x| x.context.contains(&context))
                    .flat_map(|x| x.reports)
                    .copied(),
            ),
            Self::Level(range) => {
                Box::new(default.filter(move |r| range.contains(&r.level())).copied())
            }
            Self::Report(kind) => Box::new([kind].into_iter()),
            Self::Scope(range) => {
                Box::new(default.filter(move |r| range.contains(&r.scope())).copied())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::check::{CheckKind, Context};

    use super::*;

    #[test]
    fn parse_and_display() {
        use self::Range::*;
        use RangeOrValue::*;
        use ReportLevel::*;
        use Scope::*;

        for (s, expected) in [
            ("@all", ReportSet::All),
            ("@finalize", ReportSet::Finalize),
            // check
            ("@EbuildMetadata", ReportSet::Check(CheckKind::EbuildMetadata)),
            // context
            ("@gentoo", ReportSet::Context(Context::Gentoo)),
            ("@gentoo-inherited", ReportSet::Context(Context::GentooInherited)),
            ("@optional", ReportSet::Context(Context::Optional)),
            ("@overlay", ReportSet::Context(Context::Overlay)),
            // level
            ("@warning", ReportSet::Level(Value(Warning))),
            ("@<warning", ReportSet::Level(Range(Less(Warning)))),
            ("@<=warning", ReportSet::Level(Range(LessOrEqual(Warning)))),
            ("@=warning", ReportSet::Level(Range(Equal(Warning)))),
            ("@!=warning", ReportSet::Level(Range(NotEqual(Warning)))),
            ("@>=style", ReportSet::Level(Range(GreaterOrEqual(Style)))),
            ("@>error", ReportSet::Level(Range(Greater(Error)))),
            // report
            ("MetadataError", ReportSet::Report(ReportKind::MetadataError)),
            // scope
            ("@version", ReportSet::Scope(Value(Version))),
            ("@<package", ReportSet::Scope(Range(Less(Package)))),
            ("@<=category", ReportSet::Scope(Range(LessOrEqual(Category)))),
            ("@=repo", ReportSet::Scope(Range(Equal(Repo)))),
            ("@!=repo", ReportSet::Scope(Range(NotEqual(Repo)))),
            ("@>=package", ReportSet::Scope(Range(GreaterOrEqual(Package)))),
            ("@>version", ReportSet::Scope(Range(Greater(Version)))),
        ] {
            let set: ReportSet = s.parse().unwrap();
            assert_eq!(set, expected);
            assert_eq!(set.to_string(), s);
        }
    }
}
